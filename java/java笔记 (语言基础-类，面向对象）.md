#java 语言基础 
##学习源码，重要的是抓住架构脉络，函数的参数以及返回值
##1. 方法的重载
### 参数列表不同，同一个类，相同方法名,例如Arrays类中的重载的sort() /binarySearch（）与方法的权限修饰符，返回值类型，形参变量名以及方法体都没有关系。其中System.out.println（）就是典型的重载方法。
###参数传递方法只有一种：值传递。形参：方法定义时小括号里声明的参数  实参：方法调用时实际传递给形参的数据。
###基本数据类型：数据值 
###引用数据类型：地址值 （含变量的数据类型） 赋值的时候满足数据类型相同。 而引用类型的变量只能存储两类值，null或地址值。
##2.return的用法
###`return;`表示结束此方法；同时获得返回值
##3.内存结构
###栈结构：局部变量
###堆结构：（new出来的结构，比如对象（成员变量），数组）
###变量：成员变量（实例变量：不以static进行修饰；类变量：static修饰）vs   局部变量（方法内，方法形参，构造器，构造器形参，代码块内）  在声明成员变量时（即属性）可以指明其权限，使用权限修饰符。局部变量不可以使用权限修饰符。
####4.1 默认初始化值的问题 对于成员变量（属性）：都有默认初始化值，整型（byte,short,int,long): 0 布尔型：false  引用数据类型（类，数组，接口） ：null
##4.匿名对象的使用
###在创建的对象中没有显示的给对象赋予一个变量名称，就是匿名对象，类似python中的lambda用法，匿名对象只能调用一次。比如`new phone().send();`实际的应用场景如   
	class Phone{  
       public void show (Mail mail){   
	   phone.mail();  
	   phone.play();  
	   } 
	}   
	Phone phone =new Phone();
	phone.show(new Mail());  
##5.可变个数的形参，提供了Varargs机制，允许直接定义能和多个实参进行相匹配的形参。
##a.格式：数据类型 ... 变量名  形如`public void write(String ... strs)`
##b.当可变形参个数的方法与本类中方法名相同时，形参不同的方法之间便构成了重载。
##c.可变个数形参在方法的形参中，最多只能声明一个可变形参，而且必须声明在末尾。
##6.封装与隐藏
###我们将类的属性设置成private，同时提供公共的方法实现get和set。在创建一个类的对象之后，通过对象.属性的方式进行赋值，再加入额外的限制条件，但限制条件不能在属性声明的时候体现出来，通过方法来进行实现。若避免用户再使用“对象.属性”进行赋值，则对属性值进行private命名，声明为私有的。 此外，不对外暴露私有的方法；单例模式（将构造器私有化）。
##7.构造器：作用-a.创建对象。b.可以给对象进行初始化。创建对象的实质（new+构造器）若没有显式的定义类的构造器，则提供一个默认的空参的构造器，格式为：权限修饰符 类名（形参列表）。  其中构造器的特征为：它具有与类相同的名称，不声明返回值类型，与void不同，不能有return返回值，不能被static等修饰符修饰。  在一个类中定义多个构造器，彼此构成重载。一旦显式的定义了类的构造器，系统不再提供默认的空参构造器。
	class Person{
	String name;
	int age;
	public Person(){
	}
	public Person(String n){
	name = n;
	}
##8.`Person person = new Person();  Person person1=person`
##将person变量保存的对象地址赋给p3，导致personn1和person都指向了堆空间中的同一个对象实体。
##9. 4种权限修饰符都可以用来修饰类的内部结构：属性，方法，构造器，内部类，修饰类的话，只能用public以及缺省。其中缺省类只能被同一个包内部的类访问。
##10. 赋值的四种方式：a.默认初始化 b.显示初始化 c.构造器赋值 d.通过"对象.方法"或"对象.属性"  优先级d>c>b>a
##11.javabean: 有公共类，一个无参的构造器，有属性且有对应的get，set方法。可以使用javabean将功能，处理，值，数据库等创造的对象进行打包，它提供了一种随时随地复制和粘贴的功能，而不用关心任何改变。
##12. this修饰属性和方法时，表示当前对象。一般的，在类的方法中或者构造器中，可以使用this.属性或this.方法，调用当前的属性和方法，但通常情况都选择省略this，若方法形参与类的属性同名时，必须显式的使用this，表明此变量为属性。this关键字除了可以调用成员变量或成员方法之外，还可以作为方法的返回值。在类中定义Book类型的方法，并用this返回。
	public class Book{
		public Book getbook(){
			return this;
		}
	}
##13.this调用构造器：在类的构造器中，可以显式的使用this（形参列表),调用本类中指定的其他构造器。构造器中不能通过this(参数列表)来调用自己,如果一个类中有n个构造器，则最多有n-1个构造器使用this,规定this(参数列表)必须声明在当前构造器首行。且最多声明一个this(参数列表)。
##14.package关键字的使用：为了更好的实现项目中类的管理，提供包的概念。使用package声明类或接口所属的包，声明在源文件的首行，且同一个包下，不能命名同名的接口，类。
##15.MVC设计模式：  
* 模型层：model处理数据
* 数据对象封装：model.bean.domain	
* 数据库操作类：model.dao
* 数据库：model.db
* 控制层：controller处理业务逻辑
* 应用界面相关 controller.activity
* 存放fragment
* 显示列表的适配器
* 服务相关的 
* 抽取的基类
* 视图层 view显示数据
* 相关工具类
##16.import 使用".*"表示导入包下的所有结构，类或者接口，但如果使用的是子包下的结构，仍需要显式调用。
##17.
*	补全代码：alt+/ 
*	快速修复：ctrl+1 
*	批量导包:ctrl+shift+o
*	单行注释：ctrl+/
*	上下移动代码：alt+up/down
*	切换到下一行代码空位：shift+enter
*	撤销：ctrl+z
*	反撤销：ctrl+y
*	格式化代码：ctrl+shift+f
*	在当前类中显示类结构并支持搜索：ctrl+o
*	调出get/set/构造器等方法：alt+shift+s
*	快速查找，方便查看源码：ctrl+k

##18.对于继承，父类中声明为private的属性与方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只有因为封装性的影响，使子类不能直接调用父类结构而已。而所有的java类都直接或间接的继承java.lang.Object类。
##19.方法重写：子类在继承父类的时候，可以对父类中同名同参数的方法进行覆盖操作，在重写以后创建子类对象，通过子类对象再调用方法。其中子类重写的方法权限修饰符不小于父类的。其中，子类不能重写父类中声明为private的方法。而父类被重写的方法返回值类型为void，子类的方法返回值类型只能为void。若父类被重写的方法返回值类型为A类型，而子类的方法返回值类型可以是A类或A类的子类。若父类的返回值类型为基本数据类型，则子类的返回值类型相同。其中静态方法不可以被重写。
##20.不同包的子类中，不能调用其他类中声明为private和缺省权限的属性和方法。
##21.super的使用和this较为相像，可以理解为父类，调用属性，方法和构造器。其中，如果出现子类和父类都有同名的属性，则使用this.属性表示当前类的对象的属性（先在子类中查询，然后再去父类中查询)，而super.属性表示父类对象的属性。当调用方法时是一致的。
##22.super调用构造器，在子类的构造器中显式使用"super(形参列表)"的方式，调用父类中声明的指定的构造器。必须声明在子类构造器的首行。而在类的构造器中，针对于"this(形参列表)"或super("形参列表")只能二选一，不能同时出现。
注意：在子类的构造器中，尽管没有super显式调用，不过会默认存在一个super()会调用相应的父类构造器。且至少有一个类的构造器中使用了super。
##23.对于子类对象的实例化过程：
*	结果上，子类继承了父类之后，获取了父类的属性或方法，创建子类的对象时，在堆空间中，就会加载所有父类中声明的属性。
*	过程上，在调用了父类的构造器之后，进而调用父类的父类的构造器，直至调用了Object类中空参的构造器为止。相当于加载过所有父类的结构。
##24.在子类调取父类的私有属性时，可以使用父类属性相应的get方法。
##25.对象的多态性：父类的引用指向子类的对象。使用多态性之后，在编译期只能调用父类中声明的方法，在运行期，实际执行的是子类重写父类的方法。
##26.多态性使用前提：
*	存在类的继承关系
*	存在方法的重写
##27.多态性的存在，实现代码的通用性，可以操作多种数据库，获取数据库连接，CRUD。`public void dodata(Connection conn)`。而且对象的多态性只适用于方法，不适用于属性。
##28.多态是一种运行时行为。由于多态性，内存中实际上是加载了子类特有的属性和方法，但由于变量声明为父类型，导致编译时只能调用父类中声明的属性与方法，不能调用子类中所特有的方法。
##29.重载与重写：
*	重载:在方法调用之前，编译器就已经确定所要调用的方法，是属于早绑定；
*	重写(多态):只有等到方法调用的那一刻，编译器才会确定所要调用的具体方法，属于晚绑定。
##30.向下转型：使用强制类型转换符，在使用强转使，可能出现ClassCastException的异常
	Person person=new Man();
	Man man=(Man)person;
##31.使用instanceof:a instanceof A:判断对象a是否是类b的实例
##32.强调一下，若子类重写了父类方法，就意味着子类中定义的方法彻底覆盖了父类中的同名方法，而对于实例变量，即使子类中定义了与父类完全相同的实例变量，而该实例变量依然不可能覆盖父类中定义的实例变量。
##33.在public class类中，要熟悉方法的参数里传的是子类的对象，是父类的属性，而main方法再调用成员方法。
##34.==和equals的区别:equals()只能适用于引用数据类型，而Object类中该方法的定义是:
	public boolean equals(Object obj){
		return (this==obj);
	}
##故Object类中定义的equals()和==的作用一致，比较两个对象的地址值是否相同。
*	== 既可以比较基本类型，也可以比较引用类型(比较内存地址)
*	重写equals方法，会比较类中的相应属性是否都相等。基本是引用数据类型，比如String.
*	像String、Date、File、包装类等都重写了Object类中的equals()方法，重写以后，是比较两个对象的“实体内容”是否相同。
##String底层实际上是char型数组，在进行重写equals()方法时，可以参照String类的写法。若比较两个对象的实体内容：(name和age)
	public boolean equals(Object obj){
		if(this == obj){
			return true;
			}
		if(obj instanceof Customer){
			Customer cust=(Customer)obj;
			if(this.age==cust.age && this.namr.equals(cust.name)){
				return true;}
			else{
				return true;}
			}
		return false;}
##35.Object类中getClass()方法：返回某个对象执行的Class实例，可以通过实例调用getName()来获取类的名称。
##36.Object类中toString()的使用：
*	当输出一个对象的引用时，实际就是调用当前对象的toString()。打印某个类的对象，就会自动进行调用。
*	像String()、Date()、File()、包装类中都重写了toString()方法。
##
	public String toString(){
		return getclass().getName()+"@"+Integer.toHexString(hashCode());
	//获取类的名称+在堆空间中hashcode的十六进制值
	}
## 一般均需要对打印方法进行重写
	pubilc String toString(){
		return "Customer [name="+name+",age"+age+"]"}
##37.在使用子类继承父类的时候，如果新增其他属性，则再写新的构造器，使用super()。
##38.包装类：java提供了8种基本数据类型所对应的包装类，使得基本数据类型具有类的特征。基本数据类型-->包装类(通过调用包装类的构造器)。包装类-->基本数据类型(通过调用包装类的xxxValue,如intValue())。
##39.自动装箱与自动拆箱：通过直接声明相应的类型，来进行基本数据类型与包装类的转换。
##40.基本数据类型、包装类-->String类型：调用String重载的valueOf  ||  使用 + 进行连接运算。String类型-->基本数据类型、包装类：调用包装类的parseXxx(String s)。如：parseInt()
##41.Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]数组，保存了从-128-127范围内的整数，如果我们使用自动装箱的方式，给Integer赋值的范围内在-128-127的范围之内，可以直接只用数组中的元素，不需要重新使用new来申请内存，提高效率。
##42.之所以使用包装类，是可以将基本数据类型转化成对象传入方法的参数。
	for(int i=0;i<v.size();i++){
		Object obj=v.elementAt(i);
		int value = (int)obj;}
##43.static修饰属性以及静态变量，在创建多个对象之后，多个对象共享同一个静态变量。不用static修饰的变量为实例变量。其中，静态变量随着类的加载而加载，通过"类.静态变量"来进行调用。如：`System.out;Math.PI`而静态变量的加载要早于对象的创建。类只会加载一次，而静态变量在内存中也只存在一份，存在方法区的静态域中。
##44.正常情况下，使用类的成员方法，必须要将类进行实例化，但有时不想或者无法创建类的对象时，就可以创建静态方法，可以通过类进行直接调用。类名.成员方法();静态方法中只能调用静态的方法与属性，而非静态方法中可以调用静态的方法或属性。静态方法中不能使用this或super关键字。
##45.在开发中如何确定是否要将属性或方法声明为static，其中属性可以被多个对象所共享的，声明为static，类中的常量也常常被声明为static，操作静态属性的方法通常也设置为static，在工具类中的方法也习惯上声明为static,如Math、Arrays、Collections
##46.static的应用  可以用来统计创建对象的个数
	private static int init;
	private static int total;
	public Circle(){
		init++;
		total++;
	}
	public Circle(double radius){
		this();
		this.radius=radius;
	}
##47.在对一些私有属性设置set和get方法的时候，有时候并不需要set方法。
##48.单例模式：在整个软件系统中，对某个类只能存在一个对象实例。
*	私有化类的构造器
*	在类的内部创建类的对象
*	提供公共的方法返回类的对象
##	饿汉式实现  
*	坏处：对象加载时间过长
*	好处：线程安全
##
	class Bank(){
		private Bank(){
		}
		private static Bank instance = new Bank()
		public static Bank get(){
			return instance
			}
####因为不能创建新的对象，所以只能创建静态方法，通过类去调用。
##	懒汉式实现  
*	好处：延迟对象创建
*	坏处：线程不安全
	class Bank(){
		private Bank(){
		}
		private static Bank instance = null
		public static Bank get(){
			if(instance == null){
				instance=new Bank()
			}
			return instance
			}
####单例模式的优点：由于只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置，产生其他依赖对象，可以通过启动应用时，直接产生一个单例对象，然后永久驻留内存。如java.lang.Runtime
###应用场景：网站的计数器，应用程序的日志应用，数据库连接池的设计，读取配置文件的类。Windows的任务管理器和回收站也是典型应用。
##49.代码块
*	作用:用来初始化类、对象，大括号来创建
*	如果有修饰的话，只能用static来修饰
*	静态代码块：内部可以有输出语句，随着类的加载而加载，且只执行一次。多个静态代码块按照声明顺序来执行，且运行顺序优先于非静态代码块。静态代码块只能调用静态的属性与方法。
*	非静态代码块：随着对象的创建而执行，每创建一个对象，就执行一次;此外还可以对对象的属性进行赋值。非静态代码块即可以调用静态的属性与方法，也可以调用非静态的属性与方法。非静态代码块在每次创建对象的时候，会在构造方法之前运行，所以一般在读取成员变量的值时，只能获取到默认值null。
##50.当要求类的对象的方法只能调用一次，而且无法直接进行显示赋值，则可以使用静态代码块。
##51.在存在多个子类时，存在静态代码块以及构造器，运行顺序：由父及子，静态先行。
##52.赋值执行的先后顺序：
*	默认初始化
*	显示初始化/代码块
*	构造器初始化
*	对象.属性或对象.方法
##53.final修饰一个类，此类不能被其他类所继承，如String、System、StringBuffer类，修饰方法，则不可以被重写。如Object类中的getClass()。
##54.final修饰变量时表示常量，可以赋值的位置有：显示初始化，构造器，代码块，其中如果存在多个构造器时，必须对final修饰的变量都赋予值。
##55.抽象类不可实例化，抽象类中一定有构造器，便于子类实例化进行调用。抽象方法只有方法的声明，没有方法体。若子类重写了父类中的所有的抽象方法，此子类方可实例化，若没有全部重写，则该子类也是一个抽象类，需要abstract进行修饰。
##56.创建匿名子类的匿名对象，实际调用的依然是子类的方法(重写父类中的方法),匿名类不会显示出确定的子类，表面上是调用父类，实际是子类。
##57.模板方法中使用抽象类，确定一个抽象方法，可以在final方法中使用this调用，然后在确定业务的子类中进行重写即可。
##58.接口中不能定义构造器，接口不可以进行实例化，接口通过让类去实现(implements)的方式去使用。如果实现类覆盖了接口中所有的抽象方法，则此实现类可以实例化，若未全部实现，则该实现类仍然是一个抽象类。
注意：抽象类可以通过派生类生成实例对象，接口也可以。向上转型。
##59.正常操作是创建非匿名类的非匿名对象，如果直接将new出来的对象放进方法的调用中，就是非匿名类的匿名对象，如果使用匿名类，直接调用一次，则和抽象类的使用相似，使用接口或抽象类去创建，但不能new对象，便直接在括号之后重写方法。
##60.代理模式：声明一个代理类和一个非代理类，这两个类都实现了同一接口，在代理类中，传递了一个私有的接口属性，并创建一个构造器赋予一个接口属性的对象。
##61.工厂模式：  用来生产对象
	class CarFactory{
		public static Car getCar(String type){
			if ("奥迪".equals(type)){
				return new Audi();
			}else if ("一汽".equals(type)){
				return new YiQi();
				}
			}
	}
####简单工厂模式只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类(声明一个基类，两个子类，定义一个接口，接口内方法属性为基类，声明两个对应子类的生产对象方法)。
##62.一个子类同时继承父类，并实现接口，那么在调用父类的属性时应使用super.x，调用接口属性时，使用接口.x。
##63.在进行两个对象的属性大小比较时，其中可以在方法的形参中传入一个object类型的对象，比较的过程可以使用包装类，调用包装类的compareTo方法。
##64.java8中关于接口的一些新特性：
*	接口中定义的静态方法，只能通过接口来进行调用
*	通过实现类的对象，可以调用接口中的默认方法
*	类优先原则：如果子类继承的父类和实现的接口之中实现了同名同参数的方法，默认调用的是父类中的同名同参数方法。其中在子类的方法中调用接口中被重写的方法：接口.super.method()
##65.关于内部类的主要问题：
>###如何实例化成员内部类的对象：
####*	对于静态的成员内部类：
	Person.Dog dog=new Person.Dog()

####*非静态的成员内部类：
	Person p=new Person();
	Person.Bird bird=p.new Bird();
>###内部类的应用说明(局部内部类)
####返回实现一个实现接口的类的对象
	public Compare getCompare(){
		class Mycompare implements Compare{
			public int compareTo(Object o){
				return 0;
			}
		return new Mycompare;
		}
	}
##66.抽象类与接口的区别：
*	相同点:不能实例化，都可以被继承
*	不同点：抽象类：有构造器  接口：无构造器  
*	       多继承 vs 单继承  抽象类可以有非抽象方法和非静态变量，而接口内部的所有方法都是抽象方法。
##67.在局部内部类的方法中，如果调用局部内部类所声明的方法中的局部变量，要求此局部变量声明为final。jdk8版本之后，可以省略final的声明。外部类的成员方法和成员变量尽管都被private修饰，不过仍然可以在内部类进行调用。
##68.程序在运行时可能接收到外部传入的对象，该对象的编译时类型为Object，但是程序有需要调用该对象的运行时类型的方法。则程序需要在运行时发现对象和类的真实信息。如果在编译时根本无法预知该对象和类属于哪些类，此时必须使用反射。